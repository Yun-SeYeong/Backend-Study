# 기본 CS 지식 정리

### OSI 7계층

OSI 7계층은 네트워크 통신중 일어나는 과정을 7단계로 나눈 것을 말한다.

#### 1계층 - 물리계층

이 계층은 주로 전기적, 기계적인 특징을 이용해서 통신 케이블로 데이터를 전송하게 된다. 통신단위는 비트이다. 이계층에서는 데이터가 무엇인지, 어떤 에러가 있는지 등을 전혀 관여하지 않는다.

이계층에는 통신 케이블, 리피터, 허브 등이 있다.

#### 2계층 - 데이터 링크계층

이 계층에서는 주로 송수신 되는 정보의 오류와 흐름을 관리하여 안전하게 정보를 전달할 수 있게해준다. 따라서 오류를 찾거나 재전송하는 기능도 가지고 있다.

이 계층에는 맥주소를 가지고 있다. 전송 단위는 프레임이라고 하고 브리지, 스위치 등이 있다.

#### 3계층 - 네트워크 계층

이 계층에서는 데이터를 목적지까지 가장 안전하고 빠르게 전달한다. (라우팅)

프로토콜의 종류가 다양하고 라우팅하는 기술도 다양하다. 2계층과의 차이는 IP를 가지고 있다. 

네트워크 계층은 여러개의 노드를 거칠때마다 경로를 찾아주는 역활을 하는 계층으로 전달하고 Qos를 제공하기 위해 기능적, 절차적 수단을 제공한다.

#### 4계층 - 전송 계층

통신을 활성화하기 위한 계층이다. TCP/UDP 프로토콜을 주로 이용하며, 포트를 통해 응용프로그램 간 통신을 지원한다.

주 역활은 상위 계층에 데이터 전달의 유효성, 효율성을 생각하지 않도록 한다.

#### 5계층 - 세션 계층

데이터가 통신하기 위한 논리적인 연결을 지원한다. 이 계층에서는 세션 설정, 유지, 종료, 전송 중단시 복구등 기능을 하지만 4계층과는 다르게 응용프로그램 관점으로 봐야한다.

#### 6계층 - 표현 계층

데이터 표현이 상이한 응용 프로세스의 독립성을 제공하고, 암호화한다. MIME 인코딩이나 암호화 등의 동작을 한다.

#### 7계층 -응용 계층

HTTP, FTP, SMTP, POP3, IMAP, Telnet 등의 프로토콜이 있다. 응용 서비스를 수행한다.



# 면접질문 정리

## 1. [https://www.google.com을](https://www.google.com%EC%9D%84) 접속할 때 일어나는 일

브라우저를 통해 HTTP 요청을 하게되면 먼저 요청한 HTTP Request Message를 생성하고 OS에 전송 요청을 한다. OS는 domain을 보고 DNS Lookup을 시도한다. 먼저 해당 PC의 Host파일을 보고 다음은 Local DNS Server에서 찾는다. 만약 도메인이 등록되어 있다면 IP를 전달하고 없다면 루트 DNS Server로 DNS Query를 한다. 루트 DNS서버는 최상위 도메인인 .com DNS서버의 IP주소를 알려준다. Local DNS 서버는 다시 google.com에 DNS Query를 수행하고 [www.google.com이](http://www.google.com%EC%9D%B4) 있으므로 해당 IP를 받게된다. 이과정을 Recursive Query라고 한다.

DNS Lookup이 완료되었으면 OS내부에 프로토콜 스택을 호출한다. 제일 먼저 응용계층에서 해당 Request를 패킷으로 쪼개어 전송 계층으로 전달하고 TCP or UDP 통신을 시작한다. 이 과정에서 클라이언트와 서버의 포트번호를 Header에 추가되어 세그먼트가 된다. 그리고 네트워크 계층으로 전달한다. 여기서는 서버와 클라이언트의 IP가 헤더로 붙게 된다. 그리고 데이터 링크 레이어에서는 헤더에 mac을 붙이고 마지막으로 physics layer에서 전기신호로 변환하여 스위치에서 라우터를 거쳐 Google의 서버로 전송된다. 전송된 데이터는 서버에서 필요한 리소스를 검색한뒤 요청한 과정대로 다시 클라이언트한테 응답하게 된다.

### 2. Cache 종류

Hit는 데이터를 CDN 서버에 저장하고 있다.

MISS는 데이터가 없어 Origin에 요청한다.

BYPASS 캐시하지 않는다.

Expired: 해당 요청이 만료되었을때 origin에서 데이터를 가져온다.

REVALIDATE는 해당 요청에 Last-Modified를 보고 변경되었으면 Origin에서 다시 가져온다.

STALE는 해당 요청에 응답을 받을 수 없다을 경우

## 3. TCP와 UDP의 차이

TCP는 트렌스포트 레이어에서 패킷에 클라이언트측과 서버측의 Port를 붙여서 세스먼트를 만들고 이를 전송계층에서 전달하게 되는데 이때 오류가 발생하면 해당 세스먼트를 재전송한다. 따라서 안전성이 확보되지만 전송속도가 저하될 수 있다.

UDP는 세그먼트 전송 과정에서 오류가 발생한지 알 수 없다. 따라서 안전성이 떨어지지만 속도가 빠르다. 주로 스트리밍에 쓰인다.

## 4. TCP 3,4 way handshake

3way handshake는 가상회선을 수립하는 단계로 총 3번의 세그먼트 교환으로 이루어진다. 이는 서버와 클라이언트가 서로 데이터 전송이 가능한 상태인지 확인하는 단계이다. 기본적으로 클라이언트는 CLOSED 상태이고 서버는 CLOSED상태에서 LISTEN상태로 변경된 상태이다. 먼저 클라이언트는 SYN 패킷 에 시퀀스 번호를 포한하여 전달하고 SYN_SENT 상태가 된다. 서버는 SYN 패킷을 받고 ACK(시퀀스 넘버 + 1) 와 SYN(새로운 시퀀스 번호) 패킷을 다시 전달한다. 그리고 SYN_RECEIVED 상태가 된다. 그리고 클라이언트는 ESTABLISHED 상태가 된다. 그리고 ACK(시퀀스 번호 + 1) 패킷을 보내게 된다. 서버도 ESTABLISHED 상태가 된다. 이후에는 데이터가 전송하고 받을 수 있는 상태가 된다.

4way handshake는 TCP 연결을 해제하는 단계로 총 4번의 세그먼트 교환으로 이루어진다. 먼저 client는 established 상태에서 close를 호출하고 FIN 신호를 서버로 보내게 되고 FIN_WAIT_1상태가 된다. 신호를 받은 서버는 CLOSE_WAIT 상태가 되고 ACK 신호를 보낸다 그리고 close를 호출한다. 만약 전송할 데이터가 남아있다면 전송한다. 그리고 FIN 신호를 보내고 LAST_ACK상태가 된다. 클라이언트는 timeout 상태가 되고 서버로 ack신호를 보낸다 서버는 closed 상태가 되고 클라이언트는 일정시간 이후 closed상태가 된다. 클라이언트가 timeout상태를 갖는 이유는 데드락에 걸릴 수 있기때문입니다.

### JVM 구조와 Java의 실행방식

Java는 OS에 종속적이지 않고 프로그램을 동작시킬 수 있는데 이유는 JVM이 OS를 제어하기 위해 필요한 일을 대신 해주기 때문이다.

Java코드는 JVM에서 인식하지 못한다. 따라서 JVM에서 인식할 수 있는 바이트코드로 변환해야한다. 이때 .class 파일이 된다.

JVM은 클래스 로더, Excution Engine, Runtime Data Area로 구성된다.

클래스로더는 JVM내에 클래스 파일을 로드하고 링크한다.

Execution Engine은 바이트코드를 실제로 실행 가능한 상태로 변환한다. 종류로는 인터프리터, JIT, Garbage Collector가 있다. 인터프리터는 바이트 코드를 명령어 단위로 읽고 실행한다. JIT는 특정 시점에서 바이트 코드 전체를 컴파일하여 실행한다. Garbage Collector는 사용하지 않는 인스턴스를 제거한다.

Runtime Data Area는 프로그램을 수행하기 위해 OS로 부터 할당받은 메모리공간이다.
